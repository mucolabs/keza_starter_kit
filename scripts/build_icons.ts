import { parse } from 'node-html-parser'
import { exec } from 'node:child_process'
import { existsSync } from 'node:fs'
import { glob, mkdir, readFile, writeFile } from 'node:fs/promises'
import { join, relative } from 'node:path'

class SpriteBuilder {
  #inputDir: string
  #outputDir: string

  constructor(input: { inputDir: string; outputDir: string }) {
    this.#inputDir = input.inputDir
    this.#outputDir = input.outputDir
  }

  async make() {
    await mkdir(this.#outputDir, { recursive: true })
    const files = await this.#getSVGFiles()

    if (!files.length) {
      throw new Error(`No SVG files found in ${this.#inputDir}`)
    }

    await this.#createIconFiles({ files })
  }

  async #getSVGFiles() {
    let files: Array<string> = []

    for await (const file of glob('**/*.svg', { cwd: this.#inputDir })) {
      files = [...files, file]
    }

    return files.sort((a, b) => a.localeCompare(b))
  }

  async #createIconFiles({ files }: { files: Array<string> }) {
    const spriteFilePath = join(process.cwd(), 'public', 'sprite.svg')
    const typeFilePath = join(this.#outputDir, 'sprite.d.ts')

    const existingSpriteFileContent = await this.#readFile(spriteFilePath)
    const existingTypeFileContent = await this.#readFile(typeFilePath)

    const isSpriteContentUpToDate = files
      .map((file) => {
        return file.replace(/\.svg$/, '')
      })
      .every((fileName) => {
        return existingSpriteFileContent.includes(`id=${fileName}`)
      })

    const isTypeContentUpToDate = files
      .map((file) => {
        return file.replace(/\.svg$/, '')
      })
      .every((fileName) => {
        return existingTypeFileContent.includes(fileName)
      })

    if (isSpriteContentUpToDate && isTypeContentUpToDate) {
      console.log('Icons are up to date')
      return
    }

    console.log(
      `Generating sprite for ${relative(process.cwd(), this.#inputDir)}`
    )

    const isSpriteContentChanged = await this.#createSpriteFile({
      files,
      outputPath: spriteFilePath,
    })

    for (const file of files) {
      console.log('\u2713', file)
    }

    console.log(`Saved to ${relative(process.cwd(), spriteFilePath)}`)

    if (isSpriteContentChanged) {
      await this.#writeReactComponentContent()
    }
    const { isReadmeContentChanged, isTypeContentChanged } =
      await this.#writeTypeContent({ files, outputFilePath: typeFilePath })

    if (
      isSpriteContentChanged &&
      isReadmeContentChanged &&
      isTypeContentChanged
    ) {
      console.info(`Generated ${files.length} icons`)
    }
  }

  async #createSpriteFile({
    files,
    outputPath,
  }: {
    files: Array<string>
    outputPath: string
  }) {
    const symbols = await Promise.all(
      files.map(async (file) => {
        const svgFileContent = await this.#readFile(join(this.#inputDir, file))
        const rootNode = parse(svgFileContent as string)

        const svg = rootNode.querySelector('svg')
        if (!svg) {
          throw new Error('No svg element found')
        }

        svg.tagName = 'symbol'
        svg.setAttribute('id', file.replace(/\.svg$/, ''))
        svg.removeAttribute('xmlns')
        svg.removeAttribute('xmlns:xlink')
        svg.removeAttribute('version')
        svg.removeAttribute('width')
        svg.removeAttribute('height')

        return svg.toString().trim()
      })
    )

    const outputContent = [
      `<?xml version="1.0" encoding="UTF-8"?>`,
      `<!-- This file is generated by npm run build:icons -->`,
      `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="0" height="0">`,
      `<defs>`, // for semantics: https://developer.mozilla.org/en-US/docs/Web/SVG/Element/defs
      ...symbols,
      `</defs>`,
      `</svg>`,
      '', // trailing newline
    ].join('\n')

    return this.#writeIfChanged(outputPath, outputContent)
  }

  async #writeTypeContent({
    files,
    outputFilePath,
  }: {
    files: Array<string>
    outputFilePath: string
  }) {
    const outputContent = `
      // This file is generated by npm run icons:build
      export type IconName =
      \t| ${files
        .map((file) => file.replace(/\.svg$/, ''))
        .map((name) => JSON.stringify(name))
        .join('\n\t| ')}
    `

    const isTypeContentChanged = await this.#writeIfChanged(
      outputFilePath,
      outputContent
    )
    console.log(`Manifest saved to ${relative(process.cwd(), outputFilePath)}`)

    const isReadmeContentChanged = await this.#writeIfChanged(
      join(this.#outputDir, 'readme.md'),
      ` #Icons
        This directory contains SVG icons that are used by the app.
        Everything in this directory is generated by \`npm run build:icons\`.
      `
    )

    return { isReadmeContentChanged, isTypeContentChanged }
  }

  async #writeReactComponentContent() {
    const outputFilePath = join(this.#outputDir, 'icon.tsx')
    const outputContent = `
    import { type SVGProps } from "react";
import { cn } from "~/utils/css";
import { type IconName } from "./sprite";
import sprite from "./sprite.svg";

const sizes = {
  default: "w-[1em] h-[1em]", // font size
  xs: "w-3 h-3",
  sm: "w-5 h-5",
  md: "w-5 h-5",
  lg: "w-6 h-6",
  xl: "w-7 h-7",
  "2xl": "w-14 h-14",
  "3xl": "w-21 h-21",
  "4xl": "w-28 h-28",
  "5xl": "w-35 h-35",
  "6xl": "w-42 h-42",
} as const;

type Size = keyof typeof sizes;

export type IconProps = SVGProps<SVGSVGElement> & {
  name?: IconName;
  size?: Size;
};

export function Icon(props: IconProps) {
  const { name, size = "default", className, ...rest } = props;

  return (
    <svg
      {...rest}
      className={cn("inline h-4 w-4 self-center", sizes[size], className)}
    >
      <use href={\`/sprite.svg#\${name}\`} />
    </svg>
  );
}

    `

    return this.#writeIfChanged(outputFilePath, outputContent)
  }

  async #readFile(path: string) {
    if (!existsSync(path)) {
      await writeFile(path, '')
      return readFile(path, 'utf8')
    }

    return readFile(path)
  }

  async #writeIfChanged(filePath: string, newContent: string) {
    const currentContent = await this.#readFile(filePath)

    if (currentContent === newContent) {
      return false
    }

    await writeFile(filePath, newContent, 'utf8')
    exec(`prettier --write, ${filePath} --ignore-unkown`)
    return true
  }
}

new SpriteBuilder({
  inputDir: join(process.cwd(), 'resources', 'assets', 'icons'),
  outputDir: join(process.cwd(), 'resources', 'components', 'icons'),
}).make()
